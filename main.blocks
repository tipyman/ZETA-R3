<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="Q(I)s}N+lJCe1!E9feKq" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="y7YK|{D8J$vEhU%U!X1{"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace ZETA_R3 {" line1="    let buffer: Buffer = Buffer.create(0)" line2="    let dataBuffer = pins.createBuffer(1);" line3="    pins.digitalWritePin(DigitalPin.P2, 0)  // Wakeup off" line4="" line5="    /**" line6="     * Binary data transmission over UART" line7="     * @param TX_data: 8bit data " line8="    */" line9="    function UART_BIN_TX(TX_data: number): void {" line10="        dataBuffer.setUint8(0, TX_data);" line11="        // Write buffer to serial port" line12="        serial.writeBuffer(dataBuffer)" line13="    }" line14="" line15="    /**" line16="     * Binary data reception over UART" line17="     * @param value: none" line18="     * @return value: 16bit data If return value is 256, reception time out. " line19="    */" line20="    // Check RX up to 256 times" line21="    // If data reception is OK, return reciept data, if not, retunr 0x100" line22="    function UART_BIN_RX(): number {" line23="        buffer = serial.readBuffer(1)" line24="        if (buffer.length &gt; 0) {" line25="            return buffer[0]" line26="        }" line27="        return 0x100" line28="    }" line29="" line30="    // CRC16 XMODEM calculation" line31="    function crc16(data: number[]) {" line32="        let crc = 0" line33="        for (let i = 0; i &lt;= data.length - 1; i++) {" line34="            crc ^= (data[i] &lt;&lt; 8)" line35="            for (let j = 0; j &lt; 8; j++) {" line36="                if ((crc &amp; 0x8000) != 0) {" line37="                    crc = (crc &lt;&lt; 1) ^ 0x1021" line38="                } else {" line39="                    crc &lt;&lt;= 1" line40="                }" line41="                crc &amp;= 0xFFFF" line42="            }" line43="        }" line44="        return crc" line45="    }" line46="" line47="    /**" line48="     * ZETA command execution" line49="     * @param TX_array : number[]" line50="     * @return Query_array[]" line51="    */" line52="    //% blockId=ZETA_command_execution block=&quot;ZETA command assert %TX_array&quot;" line53="    //% weight=80 blockGap=8" line54="    export function command_assert(TX_array: number[]) {" line55="        pins.digitalWritePin(DigitalPin.P2, 0)  // wakeup on" line56="        basic.pause(20)     // The specification requires 10 milliseconds, but settle 20msec for safety" line57="        let Array_length = TX_array.length" line58="        let crc_check = TX_array.slice(2)" line59="        let crc16_data = crc16(crc_check)" line60="        TX_array.push((crc16_data &gt;&gt; 8) &amp; 0xff)" line61="        TX_array.push(crc16_data &amp; 0xff)" line62="        let k = 0" line63="        for (let l = 0; l &lt; Array_length + 2; l++) {" line64="            UART_BIN_TX(TX_array[k])" line65="            k += 1" line66="        }" line67="        basic.pause(100)    // May not need this wait times" line68="        pins.digitalWritePin(DigitalPin.P2, 1)  // wakeup off" line69="        let Query_array = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]" line70="        Query_array = receive_query()" line71="        return Query_array" line72="    }" line73="" line74="    /**" line75="     * ZETA data transmission" line76="     * @param TX_array : number[]" line77="     * @return acknowlege: number" line78="    */" line79="    //% blockId=ZETA_data_transmission block=&quot;ZETA data transmission %TX_array&quot;" line80="    //% weight=80 blockGap=8" line81="    export function data_tx(TX_array: number[]) {" line82="        let Array_length2 = TX_array.length" line83="        let data_array = [0xfa, 0xf5, Array_length2 + 3, 2]" line84="        let Query_array2 = command_assert(data_array.concat(TX_array))" line85="        return Query_array2[3]" line86="    }" line87="" line88="    //% blockId=Inquiry MAC address block=&quot;Inquiry MAC address&quot;" line89="    //% weight=80 blockGap=8" line90="    export function Inquire_MAC(): number []{" line91="        let temp = [0, 0, 0, 0, 0, 0, 0, 0]" line92="        temp = command_assert([0xfa, 0xf5, 0x03, 0x10])" line93="        temp[0] = temp[4]" line94="        temp[1] = temp[5]" line95="        temp[2] = temp[6]" line96="        temp[3] = temp[7]" line97="        return temp" line98="    }" line99="" line100="    //% blockId= Inquire_Module_Status block=&quot;Inquire Module Status&quot;" line101="    //% weight=80 blockGap=8" line102="    export function Inquire_Module_Status(): number {" line103="        let temp2 = command_assert([0xfa, 0xf5, 0x03, 0x14])" line104="        return temp2[3]" line105="    }" line106="" line107="    //% blockId= Inquire_Version=&quot;Inquire Protocol version&quot;" line108="    //% weight=80 blockGap=8" line109="    export function Inquire_Version():number {" line110="        let temp3 = command_assert([0xfa, 0xf5, 0x03, 0])" line111="        return ((temp3[4] &lt;&lt; 8 ) + temp3[5]);" line112="    }" line113="" line114="    //% blockId= Inquire_Network_Time=&quot;Inquire network time&quot;" line115="    //% weight=80 blockGap=8" line116="    export function Inquire_Network_Time() :number []{" line117="        const temp4 = command_assert([0xfa, 0xf5, 0x03, 0x11]).slice(4, 11);" line118="        return temp4;" line119="    }" line120="" line121="    //% blockId= Inquire_Network_Quality=&quot;Inquire network quality&quot;" line122="    //% weight=80 blockGap=8" line123="    export function Inquire_Network_Quality():number {" line124="        const temp5 = command_assert([0xfa, 0xf5, 0x03, 0x13]);" line125="        return temp5[4];" line126="    }" line127="" line128="    //% blockId= Receive_query data block=&quot;Receive query data&quot;" line129="    //% weight=80 blockGap=8" line130="    export function receive_query():number [] {" line131="        let temp32 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]" line132="        let m = 0   // Waiting timer" line133="        while(1){" line134="            let data = UART_BIN_RX()" line135="            if (data == 0xfa){" line136="                break;" line137="            }" line138="            m += 1;" line139="            if (m &gt; 15){" line140="                return temp32" line141="            }" line142="        }" line143="        if (UART_BIN_RX() == 0xf5) {" line144="            temp32[0] = 0xfa" line145="            temp32[1] = 0xf5" line146="            let counter = UART_BIN_RX()" line147="            temp32[2] = counter" line148="            m = 3" line149="            for (let n = 0; n &lt; counter; n++) {" line150="                temp32[m] = UART_BIN_RX()" line151="                m += 1" line152="            }" line153="        }" line154="        return temp32" line155="    }" line156="}" numlines="157"></mutation></block></statement></block></xml>