<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="xRRgvHNlG#rZ^u`HECiY" x="20" y="20"><statement name="HANDLER"><block type="typescript_statement" id="wWOJJl^ExG8kKz`GHm3i"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace ZETA_R3 {" line1="    let buffer: Buffer = Buffer.create(0)" line2="    let dataBuffer = pins.createBuffer(1);" line3="    pins.digitalWritePin(DigitalPin.P2, 0)  // Wakeup off" line4="" line5="    /**" line6="     * Binary data transmission over UART" line7="     * @param TX_data: 8bit data " line8="    */" line9="    function UART_BIN_TX(TX_data: number): void {" line10="        dataBuffer.setUint8(0, TX_data);" line11="        // Write buffer to serial port" line12="        serial.writeBuffer(dataBuffer)" line13="    }" line14="" line15="    /**" line16="     * Binary data reception over UART" line17="     * @param value: none" line18="     * @return value: 16bit data If return value is 256, reception time out. " line19="    */" line20="    // Check RX up to 256 times" line21="    // If data reception is OK, return reciept data, if not, retunr 0x100" line22="    function UART_BIN_RX(): number {" line23="        buffer = serial.readBuffer(1)" line24="        if (buffer.length &gt; 0) {" line25="            return buffer[0]" line26="        }" line27="        return 0x100" line28="    }" line29="" line30="    // CRC16 XMODEM calculation" line31="    function crc16(data: number[]) {" line32="        let crc = 0" line33="        for (let i = 0; i &lt;= data.length - 1; i++) {" line34="            crc ^= (data[i] &lt;&lt; 8)" line35="            for (let j = 0; j &lt; 8; j++) {" line36="                if ((crc &amp; 0x8000) != 0) {" line37="                    crc = (crc &lt;&lt; 1) ^ 0x1021" line38="                } else {" line39="                    crc &lt;&lt;= 1" line40="                }" line41="                crc &amp;= 0xFFFF" line42="            }" line43="        }" line44="        return crc" line45="    }" line46="" line47="    /**" line48="     * ZETA command execution" line49="     * @param TX_array : number[]" line50="     * @return Query_array[]" line51="    */" line52="    //% blockId=ZETA_command_execution block=&quot;ZETA command assert %TX_array&quot;" line53="    //% weight=80 blockGap=8" line54="    export function command_assert(TX_array: number[]) {" line55="        pins.digitalWritePin(DigitalPin.P2, 0)  // wakeup on" line56="        basic.pause(20)     // The specification requires 10 milliseconds, but settle 20msec for safety" line57="        let Array_length = TX_array.length" line58="        let crc_check = TX_array.slice(2)" line59="        let crc16_data = crc16(crc_check)" line60="        TX_array.push((crc16_data &gt;&gt; 8) &amp; 0xff)" line61="        TX_array.push(crc16_data &amp; 0xff)" line62="        let k = 0" line63="        for (let l = 0; l &lt; Array_length + 2; l++) {" line64="            UART_BIN_TX(TX_array[k])" line65="            k += 1" line66="        }" line67="        basic.pause(100)    // May not need this wait times" line68="        pins.digitalWritePin(DigitalPin.P2, 1)  // wakeup off" line69="        let Query_array = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]" line70="        Query_array = receive_query()" line71="        return Query_array" line72="    }" line73="" line74="    /**" line75="     * ZETA data transmission" line76="     * @param TX_array : number[]" line77="     * @return acknowlege: number" line78="    */" line79="    //% blockId=ZETA_data_transmission block=&quot;ZETA data transmission %TX_array&quot;" line80="    //% weight=80 blockGap=8" line81="    export function data_tx(TX_array: number[]) {" line82="        let Array_length2 = TX_array.length" line83="        let data_array = [0xfa, 0xf5, Array_length2 + 3, 2]" line84="        let Query_array2 = command_assert(data_array.concat(TX_array))" line85="        return Query_array2[3]" line86="    }" line87="" line88="    //% blockId=Inquiry MAC address block=&quot;Inquiry MAC address&quot;" line89="    //% weight=80 blockGap=8" line90="    export function Inquire_MAC() {" line91="        let temp = [0, 0, 0, 0, 0, 0, 0, 0]" line92="        temp = command_assert([0xfa, 0xf5, 0x03, 0x10])" line93="        temp[0] = temp[4]" line94="        temp[1] = temp[5]" line95="        temp[2] = temp[6]" line96="        temp[3] = temp[7]" line97="        return temp" line98="    }" line99="" line100="    //% blockId= Inquire_Module_Status block=&quot;Inquire Module Status&quot;" line101="    //% weight=80 blockGap=8" line102="    export function Inquire_Module_Status() {" line103="        let temp2 = command_assert([0xfa, 0xf5, 0x03, 0x14])" line104="        return temp2[3]" line105="    }" line106="" line107="    //% blockId= Receive_query data block=&quot;Receive query data&quot;" line108="    //% weight=80 blockGap=8" line109="    export function receive_query() {" line110="        let temp3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]" line111="        let m = 0   // Waiting timer" line112="        while(1){" line113="            let data = UART_BIN_RX()" line114="            if (data == 0xfa){" line115="                break;" line116="            }" line117="            m += 1;" line118="            if (m &gt; 15){" line119="                return temp3" line120="            }" line121="        }" line122="        if (UART_BIN_RX() == 0xf5) {" line123="            temp3[0] = 0xfa" line124="            temp3[1] = 0xf5" line125="            let counter = UART_BIN_RX()" line126="            temp3[2] = counter" line127="            m = 3" line128="            for (let n = 0; n &lt; counter; n++) {" line129="                temp3[m] = UART_BIN_RX()" line130="                m += 1" line131="            }" line132="        }" line133="        return temp3" line134="    }" line135="}" numlines="136"></mutation></block></statement></block></xml>